<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Configuraci칩n de Filtro</title>
  <link rel="stylesheet" href="/static/styles.css">
  <script src="/static/common.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="page-header">
      <h1 id="pageTitle">Configuraci칩n de Filtro</h1>
      <button class="btn btn-primary" onclick="goBackToFilterConfig()">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
          <path d="M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 1 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8z"/>
        </svg>
        Volver a Configuraci칩n de Filtros
      </button>
    </div>

    <div class="filter-config-container">
      <div id="filterConfigContent">
        <!-- El contenido se generar치 din치micamente seg칰n el tipo de filtro -->
      </div>

      <div class="config-actions">
        <button class="btn btn-secondary" onclick="resetFilterConfig()">Restablecer</button>
        <button class="btn btn-primary" onclick="applyFilterConfig()">Aplicar</button>
        <button class="btn btn-success" onclick="saveFilterConfig()">Guardar</button>
        <button class="btn btn-warning" onclick="startAutoTune()" id="autoTuneBtn">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
            <path d="M8 3a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5H6a.5.5 0 0 1 0-1h1.5V3.5A.5.5 0 0 1 8 3zm3.5 1a.5.5 0 0 1 .5.5v3.5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1H11V2.5a.5.5 0 0 1 .5-.5z"/>
            <path d="M8 12a.5.5 0 0 1 .5-.5h1.5v-2H8a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5v2.5a.5.5 0 0 1-.5.5H8.5V12a.5.5 0 0 1-.5.5z"/>
          </svg>
          Autotune
        </button>
      </div>
    </div>
  </div>

  <script>
    let currentFilterId = null;
    let currentFilterType = null;
    let noiseLevel = 0;
    let edgeSharpness = 0;
    let saltPepperNoise = 0;
    let morphologicalQuality = 0;

    // Funci칩n para volver a la p치gina de configuraci칩n de filtros
    function goBackToFilterConfig() {
      if (window.parent && window.parent.setLeftPane) {
        window.parent.setLeftPane('filter_config');
      } else {
        window.location.href = '/template/filter_config.html';
      }
    }

    // Funci칩n para cargar la configuraci칩n del filtro desde los par치metros de URL
    function loadFilterConfig() {
      const urlParams = new URLSearchParams(window.location.search);
      currentFilterId = urlParams.get('filterId');
      currentFilterType = urlParams.get('filterType');
      
      if (!currentFilterId || !currentFilterType) {
        showStatus('Error: Par치metros de filtro no v치lidos', 'error');
        return;
      }

      // Actualizar t칤tulo de la p치gina
      document.getElementById('pageTitle').textContent = 
        `Configurar Filtro ${currentFilterId}: ${getFilterDisplayName(currentFilterType)}`;

      // Generar controles seg칰n el tipo de filtro
      const configContent = document.getElementById('filterConfigContent');
      configContent.innerHTML = generateFilterControls(currentFilterType);

      // Configurar listeners despu칠s de generar el HTML
      setTimeout(() => {
        setupSliderListeners();
        loadCurrentFilterParams(currentFilterType);
        startMetricsUpdate();
      }, 10);
    }

    // Funci칩n para obtener nombre de visualizaci칩n del filtro
    function getFilterDisplayName(filterType) {
      const names = {
        'bilateral': 'Filtro Bilateral',
        'gaussian': 'Filtro Gaussiano',
        'median': 'Filtro de Mediana',
        'morphological': 'Operaciones Morfol칩gicas',
        'aggressive': 'Filtro Agresivo',
        'contour_clean': 'Limpieza de Contorno',
        'default': 'Filtro por Defecto'
      };
      return names[filterType] || filterType;
    }

    // Funci칩n para generar controles seg칰n el tipo de filtro
    function generateFilterControls(filterType) {
      switch(filterType) {
        case 'bilateral':
          return `
            <div class="config-section">
              <h3>Par치metros del Filtro Bilateral</h3>
              <p class="filter-description">
                El filtro bilateral es una t칠cnica avanzada de suavizado que preserva los bordes y detalles importantes mientras reduce el ruido. 
                A diferencia de otros filtros que suavizan uniformemente, el bilateral analiza tanto la distancia espacial como la diferencia de color 
                entre p칤xeles, permitiendo un suavizado inteligente que mantiene la nitidez de los contornos. Es especialmente 칰til para im치genes 
                con mucho ruido pero donde necesitas preservar detalles finos como bordes de objetos o texturas importantes.
              </p>
              
              <div class="metrics-panel">
                <h4>Indicadores de Calidad</h4>
                <div class="metrics-grid">
                  <div class="metric-card">
                    <div class="metric-header">
                      <span class="metric-label">Nivel de Ruido</span>
                      <span class="metric-value" id="noiseLevelValue">0%</span>
                    </div>
                    <div class="metric-bar">
                      <div class="metric-fill" id="noiseLevelBar" style="width: 0%"></div>
                    </div>
                    <small class="metric-description">Menor = Mejor</small>
                  </div>
                  <div class="metric-card">
                    <div class="metric-header">
                      <span class="metric-label">Nitidez de Bordes</span>
                      <span class="metric-value" id="edgeSharpnessValue">0%</span>
                    </div>
                    <div class="metric-bar">
                      <div class="metric-fill" id="edgeSharpnessBar" style="width: 0%"></div>
                    </div>
                    <small class="metric-description">Mayor = Mejor</small>
                  </div>
                </div>
              </div>
              
              <div class="optimization-info">
                <h4>游 Optimizaci칩n Autom치tica</h4>
                <p>
                  El bot칩n <strong>Autotune</strong> analiza autom치ticamente todas las combinaciones posibles de par치metros 
                  para encontrar la configuraci칩n 칩ptima. El proceso eval칰a el balance entre reducci칩n de ruido y preservaci칩n 
                  de bordes, y puede tomar varios minutos dependiendo de la complejidad del filtro.
                </p>
              </div>
              
              <div class="form-group">
                <label for="bilateralD">Di치metro del kernel (d):</label>
                <div class="range-container">
                  <input type="range" id="bilateralD" min="5" max="25" value="15" class="range-slider">
                  <label class="slider-value" id="bilateralDValue">15</label>
                </div>
                <small class="param-description">
                  Define el tama침o del 치rea de influencia alrededor de cada p칤xel. Un valor m치s alto significa que se consideran m치s p칤xeles vecinos 
                  para el c치lculo, resultando en un suavizado m치s intenso. Sin embargo, valores muy altos pueden hacer el proceso m치s lento. 
                  Recomendado: 15 para la mayor칤a de casos.
                </small>
              </div>
              
              <div class="form-group">
                <label for="bilateralSigmaColor">Sigma Color:</label>
                <div class="range-container">
                  <input type="range" id="bilateralSigmaColor" min="25" max="150" value="75" class="range-slider">
                  <label class="slider-value" id="bilateralSigmaColorValue">75</label>
                </div>
                <small class="param-description">
                  Controla qu칠 tan diferentes pueden ser los colores para ser considerados similares. Un valor bajo preserva mejor los bordes 
                  porque solo p칤xeles con colores muy similares se promedian entre s칤. Un valor alto permite que p칤xeles con colores m치s diferentes 
                  se mezclen, resultando en m치s suavizado pero posiblemente perdiendo algunos detalles.
                </small>
              </div>
              
              <div class="form-group">
                <label for="bilateralSigmaSpace">Sigma Space:</label>
                <div class="range-container">
                  <input type="range" id="bilateralSigmaSpace" min="25" max="150" value="75" class="range-slider">
                  <label class="slider-value" id="bilateralSigmaSpaceValue">75</label>
                </div>
                <small class="param-description">
                  Determina qu칠 tan lejos pueden estar los p칤xeles para ser considerados en el c치lculo. Un valor bajo significa que solo p칤xeles 
                  muy cercanos influyen en el resultado, preservando mejor los detalles locales. Un valor alto permite que p칤xeles m치s distantes 
                  contribuyan, creando un suavizado m치s uniforme pero menos detallado.
                </small>
              </div>
            </div>
          `;
        
        case 'gaussian':
          return `
            <div class="config-section">
              <h3>Par치metros del Filtro Gaussiano</h3>
              <p class="filter-description">
                El filtro gaussiano es un m칠todo cl치sico y muy efectivo para suavizar im치genes y reducir ruido. Utiliza una funci칩n matem치tica 
                llamada distribuci칩n gaussiana (campana de Gauss) para calcular el promedio ponderado de los p칤xeles vecinos. Este filtro es 
                especialmente 칰til para eliminar ruido gaussiano y suavizar texturas finas sin crear artefactos visibles. Es r치pido, eficiente 
                y produce resultados consistentes, aunque puede suavizar ligeramente los bordes.
              </p>
              
              <div class="metrics-panel">
                <h4>Indicadores de Calidad</h4>
                <div class="metrics-grid">
                  <div class="metric-card">
                    <div class="metric-header">
                      <span class="metric-label">Nivel de Ruido</span>
                      <span class="metric-value" id="noiseLevelValue">0%</span>
                    </div>
                    <div class="metric-bar">
                      <div class="metric-fill" id="noiseLevelBar" style="width: 0%"></div>
                    </div>
                    <small class="metric-description">Menor = Mejor</small>
                  </div>
                  <div class="metric-card">
                    <div class="metric-header">
                      <span class="metric-label">Suavizado</span>
                      <span class="metric-value" id="smoothingLevelValue">0%</span>
                    </div>
                    <div class="metric-bar">
                      <div class="metric-fill" id="smoothingLevelBar" style="width: 0%"></div>
                    </div>
                    <small class="metric-description">Balance 칩ptimo</small>
                  </div>
                </div>
              </div>
              
              <div class="optimization-info">
                <h4>游 Optimizaci칩n Autom치tica</h4>
                <p>
                  El bot칩n <strong>Autotune</strong> analiza autom치ticamente todas las combinaciones posibles de par치metros 
                  para encontrar la configuraci칩n 칩ptima. El proceso eval칰a el balance entre suavizado y preservaci칩n de detalles, 
                  y puede tomar varios minutos dependiendo de la complejidad del filtro.
                </p>
              </div>
              
              <div class="form-group">
                <label for="gaussianKernelSize">Tama침o del kernel:</label>
                <div class="range-container">
                  <input type="range" id="gaussianKernelSize" min="3" max="15" step="2" value="5" class="range-slider">
                  <label class="slider-value" id="gaussianKernelSizeValue">5</label>
                </div>
                <small class="param-description">
                  Define el tama침o de la ventana de p칤xeles que se usa para calcular el promedio. Debe ser un n칰mero impar (3, 5, 7, etc.). 
                  Un kernel m치s grande (ej: 7x7, 9x9) produce un suavizado m치s intenso pero puede hacer que los bordes se vean borrosos. 
                  Un kernel peque침o (ej: 3x3, 5x5) preserva mejor los detalles pero reduce menos el ruido. Para la mayor칤a de aplicaciones, 
                  un kernel de 5x5 es un buen balance.
                </small>
              </div>
              
              <div class="form-group">
                <label for="gaussianSigma">Sigma:</label>
                <div class="range-container">
                  <input type="range" id="gaussianSigma" min="0.1" max="3.0" step="0.1" value="1.0" class="range-slider">
                  <label class="slider-value" id="gaussianSigmaValue">1.0</label>
                </div>
                <small class="param-description">
                  Controla la intensidad del suavizado aplicando diferentes pesos a los p칤xeles seg칰n su distancia al centro. Un sigma bajo 
                  (0.1-0.5) produce un suavizado sutil que preserva la mayor칤a de los detalles. Un sigma alto (1.5-3.0) crea un suavizado 
                  m치s agresivo que elimina m치s ruido pero puede perder algunos detalles finos. Un sigma de 1.0 es el valor est치ndar que 
                  funciona bien para la mayor칤a de im치genes.
                </small>
              </div>
            </div>
          `;
        
        case 'median':
          return `
            <div class="config-section">
              <h3>Par치metros del Filtro de Mediana</h3>
              <p class="filter-description">
                El filtro de mediana es especialmente poderoso para eliminar ruido de "sal y pimienta" - p칤xeles individuales que son mucho 
                m치s claros o m치s oscuros que sus vecinos. A diferencia de otros filtros que promedian valores, la mediana selecciona el valor 
                del medio de todos los p칤xeles en la ventana, lo que hace que sea muy resistente a valores at칤picos extremos. Este filtro 
                preserva excelentemente los bordes y detalles importantes, pero es menos efectivo contra ruido gaussiano uniforme.
              </p>
              
              <div class="metrics-panel">
                <h4>Indicadores de Calidad</h4>
                <div class="metrics-grid">
                  <div class="metric-card">
                    <div class="metric-header">
                      <span class="metric-label">Ruido Sal y Pimienta</span>
                      <span class="metric-value" id="saltPepperNoiseValue">0%</span>
                    </div>
                    <div class="metric-bar">
                      <div class="metric-fill" id="saltPepperNoiseBar" style="width: 0%"></div>
                    </div>
                    <small class="metric-description">Menor = Mejor</small>
                  </div>
                  <div class="metric-card">
                    <div class="metric-header">
                      <span class="metric-label">Preservaci칩n de Bordes</span>
                      <span class="metric-value" id="edgePreservationValue">0%</span>
                    </div>
                    <div class="metric-bar">
                      <div class="metric-fill" id="edgePreservationBar" style="width: 0%"></div>
                    </div>
                    <small class="metric-description">Mayor = Mejor</small>
                  </div>
                </div>
              </div>
              
              <div class="optimization-info">
                <h4>游 Optimizaci칩n Autom치tica</h4>
                <p>
                  El bot칩n <strong>Autotune</strong> analiza autom치ticamente todas las combinaciones posibles de par치metros 
                  para encontrar la configuraci칩n 칩ptima. El proceso eval칰a el balance entre eliminaci칩n de ruido sal y pimienta y preservaci칩n de bordes, 
                  y puede tomar varios minutos dependiendo de la complejidad del filtro.
                </p>
              </div>
              
              <div class="form-group">
                <label for="medianKernelSize">Tama침o del kernel:</label>
                <div class="range-container">
                  <input type="range" id="medianKernelSize" min="3" max="15" step="2" value="5" class="range-slider">
                  <label class="slider-value" id="medianKernelSizeValue">5</label>
                </div>
                <small class="param-description">
                  Define el tama침o de la ventana de p칤xeles donde se calcula la mediana. Debe ser un n칰mero impar. Un kernel peque침o (3x3) 
                  elimina ruido de sal y pimienta muy fino pero puede dejar pasar ruido m치s grueso. Un kernel grande (7x7, 9x9) elimina 
                  manchas m치s grandes pero puede suavizar ligeramente los bordes. Para la mayor칤a de casos, un kernel de 5x5 es 칩ptimo: 
                  elimina ruido efectivamente sin afectar significativamente los detalles importantes.
                </small>
              </div>
            </div>
          `;
        
        case 'morphological':
          return `
            <div class="config-section">
              <h3>Par치metros de Operaciones Morfol칩gicas</h3>
              <p class="filter-description">
                Las operaciones morfol칩gicas son t칠cnicas matem치ticas que modifican la forma y estructura de los objetos en una imagen 
                bas치ndose en un elemento estructurante (kernel). Estas operaciones son fundamentales en el procesamiento de im치genes 
                para tareas como limpieza de ruido, relleno de huecos, detecci칩n de bordes y mejora de la conectividad entre objetos. 
                Cada tipo de operaci칩n tiene un prop칩sito espec칤fico y puede combinarse para lograr efectos m치s complejos.
              </p>
              
              <div class="metrics-panel">
                <h4>Indicadores de Calidad</h4>
                <div class="metrics-grid">
                  <div class="metric-card">
                    <div class="metric-header">
                      <span class="metric-label">Calidad Morfol칩gica</span>
                      <span class="metric-value" id="morphologicalQualityValue">0%</span>
                    </div>
                    <div class="metric-bar">
                      <div class="metric-fill" id="morphologicalQualityBar" style="width: 0%"></div>
                    </div>
                    <small class="metric-description">Mayor = Mejor</small>
                  </div>
                  <div class="metric-card">
                    <div class="metric-header">
                      <span class="metric-label">Conectividad</span>
                      <span class="metric-value" id="connectivityValue">0%</span>
                    </div>
                    <div class="metric-bar">
                      <div class="metric-fill" id="connectivityBar" style="width: 0%"></div>
                    </div>
                    <small class="metric-description">Mayor = Mejor</small>
                  </div>
                </div>
              </div>
              
              <div class="optimization-info">
                <h4>游 Optimizaci칩n Autom치tica</h4>
                <p>
                  El bot칩n <strong>Autotune</strong> analiza autom치ticamente todas las combinaciones posibles de par치metros 
                  para encontrar la configuraci칩n 칩ptima. El proceso eval칰a el balance entre calidad morfol칩gica y conectividad, 
                  y puede tomar varios minutos dependiendo de la complejidad del filtro.
                </p>
              </div>
              
              <div class="form-group">
                <label for="morphOperation">Tipo de operaci칩n:</label>
                <select id="morphOperation" class="form-control">
                  <option value="opening">Apertura (Opening)</option>
                  <option value="closing">Cierre (Closing)</option>
                  <option value="gradient">Gradiente</option>
                  <option value="tophat">Top Hat</option>
                  <option value="blackhat">Black Hat</option>
                </select>
                <small class="param-description">
                  <strong>Apertura:</strong> Elimina ruido y objetos peque침os, suaviza contornos. Ideal para limpiar im치genes con ruido fino.<br>
                  <strong>Cierre:</strong> Rellena huecos peque침os y conecta objetos cercanos. 칔til para completar objetos fragmentados.<br>
                  <strong>Gradiente:</strong> Encuentra y resalta los bordes de los objetos. Excelente para detecci칩n de contornos.<br>
                  <strong>Top Hat:</strong> Extrae objetos brillantes sobre fondo oscuro. Perfecto para detectar detalles claros.<br>
                  <strong>Black Hat:</strong> Extrae objetos oscuros sobre fondo claro. Ideal para detectar detalles oscuros.
                </small>
              </div>
              
              <div class="form-group">
                <label for="morphKernelSize">Tama침o del kernel:</label>
                <div class="range-container">
                  <input type="range" id="morphKernelSize" min="3" max="15" step="2" value="5" class="range-slider">
                  <label class="slider-value" id="morphKernelSizeValue">5</label>
                </div>
                <small class="param-description">
                  Controla la intensidad y escala de la operaci칩n morfol칩gica. Un kernel peque침o (3x3) produce efectos sutiles, 
                  ideales para eliminar ruido fino o detectar bordes finos. Un kernel grande (7x7, 9x9) crea efectos m치s dram치ticos, 
                  eliminando objetos m치s grandes o creando bordes m치s gruesos. El tama침o 칩ptimo depende del tama침o de los objetos 
                  que quieres procesar en tu imagen.
                </small>
              </div>
            </div>
          `;
        
        case 'noise_reduction':
          return `
            <div class="config-section">
              <h3>Par치metros de Reducci칩n de Ruido</h3>
              <p class="filter-description">
                La reducci칩n de ruido utiliza el algoritmo Non-Local Means (NLM) que es muy efectivo para eliminar ruido gaussiano y de sal y pimienta 
                mientras preserva los detalles importantes de la imagen. Este filtro analiza patrones similares en toda la imagen para determinar 
                el valor correcto de cada p칤xel, resultando en una reducci칩n de ruido muy efectiva sin p칠rdida significativa de detalles.
              </p>
              
              <div class="metrics-panel">
                <h4>Indicadores de Calidad</h4>
                <div class="metrics-grid">
                  <div class="metric-card">
                    <div class="metric-header">
                      <span class="metric-label">Reducci칩n de Ruido</span>
                      <span class="metric-value" id="noiseReductionValue">0%</span>
                    </div>
                    <div class="metric-bar">
                      <div class="metric-fill" id="noiseReductionBar" style="width: 0%"></div>
                    </div>
                    <small class="metric-description">Mayor = Mejor</small>
                  </div>
                  <div class="metric-card">
                    <div class="metric-header">
                      <span class="metric-label">Preservaci칩n de Detalles</span>
                      <span class="metric-value" id="detailPreservationValue">0%</span>
                    </div>
                    <div class="metric-bar">
                      <div class="metric-fill" id="detailPreservationBar" style="width: 0%"></div>
                    </div>
                    <small class="metric-description">Mayor = Mejor</small>
                  </div>
                </div>
              </div>
              
              <div class="optimization-info">
                <h4>游 Optimizaci칩n Autom치tica</h4>
                <p>
                  El bot칩n <strong>Autotune</strong> encuentra autom치ticamente el balance 칩ptimo entre reducci칩n de ruido y preservaci칩n de detalles.
                </p>
              </div>
              
              <div class="form-group">
                <label for="noiseReductionH">Par치metro de Filtrado (h):</label>
                <div class="range-container">
                  <input type="range" id="noiseReductionH" min="3" max="20" value="10" class="range-slider">
                  <label class="slider-value" id="noiseReductionHValue">10</label>
                </div>
                <small class="param-description">
                  Controla la intensidad de la reducci칩n de ruido. Un valor bajo (3-7) produce una reducci칩n sutil que preserva todos los detalles. 
                  Un valor alto (15-20) elimina m치s ruido pero puede suavizar ligeramente algunos detalles finos. El valor 칩ptimo depende del tipo 
                  y cantidad de ruido en tu imagen.
                </small>
              </div>
            </div>
          `;

        case 'contrast_enhance':
          return `
            <div class="config-section">
              <h3>Par치metros de Mejora de Contraste</h3>
              <p class="filter-description">
                La mejora de contraste ajusta din치micamente el rango de intensidades de la imagen para mejorar la separaci칩n entre objetos y fondo. 
                Este filtro es especialmente 칰til cuando las im치genes tienen bajo contraste o cuando necesitas mejorar la visibilidad de detalles 
                importantes para la detecci칩n de objetos.
              </p>
              
              <div class="metrics-panel">
                <h4>Indicadores de Calidad</h4>
                <div class="metrics-grid">
                  <div class="metric-card">
                    <div class="metric-header">
                      <span class="metric-label">Contraste</span>
                      <span class="metric-value" id="contrastValue">0%</span>
                    </div>
                    <div class="metric-bar">
                      <div class="metric-fill" id="contrastBar" style="width: 0%"></div>
                    </div>
                    <small class="metric-description">Mayor = Mejor</small>
                  </div>
                  <div class="metric-card">
                    <div class="metric-header">
                      <span class="metric-label">Separaci칩n de Objetos</span>
                      <span class="metric-value" id="objectSeparationValue">0%</span>
                    </div>
                    <div class="metric-bar">
                      <div class="metric-fill" id="objectSeparationBar" style="width: 0%"></div>
                    </div>
                    <small class="metric-description">Mayor = Mejor</small>
                  </div>
                </div>
              </div>
              
              <div class="optimization-info">
                <h4>游 Optimizaci칩n Autom치tica</h4>
                <p>
                  El bot칩n <strong>Autotune</strong> encuentra autom치ticamente los valores 칩ptimos de contraste y brillo para tu imagen espec칤fica.
                </p>
              </div>
              
              <div class="form-group">
                <label for="contrastAlpha">Factor de Contraste (풤):</label>
                <div class="range-container">
                  <input type="range" id="contrastAlpha" min="0.5" max="3.0" step="0.1" value="1.3" class="range-slider">
                  <label class="slider-value" id="contrastAlphaValue">1.3</label>
                </div>
                <small class="param-description">
                  Controla el factor de multiplicaci칩n para el contraste. Un valor de 1.0 no cambia el contraste. Valores menores a 1.0 reducen 
                  el contraste (hacen la imagen m치s plana). Valores mayores a 1.0 aumentan el contraste (hacen las diferencias m치s pronunciadas). 
                  Para detecci칩n de objetos, valores entre 1.2 y 1.8 suelen ser 칩ptimos.
                </small>
              </div>
              
              <div class="form-group">
                <label for="contrastBeta">Factor de Brillo ():</label>
                <div class="range-container">
                  <input type="range" id="contrastBeta" min="-50" max="50" value="20" class="range-slider">
                  <label class="slider-value" id="contrastBetaValue">20</label>
                </div>
                <small class="param-description">
                  Ajusta el brillo general de la imagen. Valores negativos oscurecen la imagen, valores positivos la aclaran. Este par치metro 
                  es 칰til para compensar cambios en el contraste o para ajustar el nivel de brillo 칩ptimo para la detecci칩n.
                </small>
              </div>
            </div>
          `;

        case 'edge_enhance':
          return `
            <div class="config-section">
              <h3>Par치metros de Mejora de Bordes</h3>
              <p class="filter-description">
                La mejora de bordes utiliza el operador Laplaciano para detectar y reforzar los bordes en la imagen. Este filtro es muy 칰til 
                para mejorar la detecci칩n de objetos ya que hace que los contornos sean m치s pronunciados y f치ciles de detectar. Es especialmente 
                efectivo cuando se aplica despu칠s de otros filtros de suavizado.
              </p>
              
              <div class="metrics-panel">
                <h4>Indicadores de Calidad</h4>
                <div class="metrics-grid">
                  <div class="metric-card">
                    <div class="metric-header">
                      <span class="metric-label">Nitidez de Bordes</span>
                      <span class="metric-value" id="edgeSharpnessValue">0%</span>
                    </div>
                    <div class="metric-bar">
                      <div class="metric-fill" id="edgeSharpnessBar" style="width: 0%"></div>
                    </div>
                    <small class="metric-description">Mayor = Mejor</small>
                  </div>
                  <div class="metric-card">
                    <div class="metric-header">
                      <span class="metric-label">Detecci칩n de Contornos</span>
                      <span class="metric-value" id="contourDetectionValue">0%</span>
                    </div>
                    <div class="metric-bar">
                      <div class="metric-fill" id="contourDetectionBar" style="width: 0%"></div>
                    </div>
                    <small class="metric-description">Mayor = Mejor</small>
                  </div>
                </div>
              </div>
              
              <div class="optimization-info">
                <h4>游 Optimizaci칩n Autom치tica</h4>
                <p>
                  El bot칩n <strong>Autotune</strong> encuentra autom치ticamente la intensidad 칩ptima de mejora de bordes para tu imagen.
                </p>
              </div>
              
              <div class="form-group">
                <label for="edgeEnhanceStrength">Intensidad de Mejora:</label>
                <div class="range-container">
                  <input type="range" id="edgeEnhanceStrength" min="0.1" max="1.0" step="0.1" value="0.5" class="range-slider">
                  <label class="slider-value" id="edgeEnhanceStrengthValue">0.5</label>
                </div>
                <small class="param-description">
                  Controla qu칠 tan intensa es la mejora de bordes. Un valor bajo (0.1-0.3) produce una mejora sutil que refuerza ligeramente 
                  los bordes existentes. Un valor alto (0.7-1.0) crea un efecto m치s dram치tico que puede hacer que los bordes sean muy pronunciados. 
                  Para detecci칩n de objetos, valores entre 0.3 y 0.7 suelen ser 칩ptimos.
                </small>
              </div>
            </div>
          `;

        default:
          return `
            <div class="config-section">
              <h3>Configuraci칩n no disponible</h3>
              <p class="filter-description">Este tipo de filtro no requiere configuraci칩n adicional o no est치 soportado actualmente en el sistema.</p>
            </div>
          `;
      }
    }

    // Funci칩n para configurar listeners de sliders
    function setupSliderListeners() {
      const sliders = document.querySelectorAll('input[type="range"]');
      sliders.forEach(slider => {
        const valueSpan = document.getElementById(slider.id + 'Value');
        if (valueSpan) {
          // Actualizar valor inicial inmediatamente
          valueSpan.textContent = slider.value;
          
          // Agregar listener para cambios
          slider.addEventListener('input', function() {
            valueSpan.textContent = this.value;
            updateMetrics();
          });
        }
      });

      // Listener para select de operaciones morfol칩gicas
      const morphSelect = document.getElementById('morphOperation');
      if (morphSelect) {
        morphSelect.addEventListener('change', updateMetrics);
      }
    }

    // Funci칩n para actualizar m칠tricas en tiempo real
    function updateMetrics() {
      const params = collectFilterParams();
      
      switch(currentFilterType) {
        case 'bilateral':
          updateBilateralMetrics(params.parameters);
          break;
        case 'gaussian':
          updateGaussianMetrics(params.parameters);
          break;
        case 'median':
          updateMedianMetrics(params.parameters);
          break;
        case 'morphological':
          updateMorphologicalMetrics(params.parameters);
          break;
        case 'noise_reduction':
          updateNoiseReductionMetrics(params.parameters);
          break;
        case 'contrast_enhance':
          updateContrastEnhanceMetrics(params.parameters);
          break;
        case 'edge_enhance':
          updateEdgeEnhanceMetrics(params.parameters);
          break;
      }
    }

    // Funci칩n para actualizar m칠tricas del filtro bilateral
    function updateBilateralMetrics(params) {
      const d = params.d || 15;
      const sigmaColor = params.sigmaColor || 75;
      const sigmaSpace = params.sigmaSpace || 75;
      
      // Calcular nivel de ruido (simulado)
      const noiseLevel = Math.max(0, 100 - (d * 2 + sigmaColor * 0.3 + sigmaSpace * 0.3));
      const edgeSharpness = Math.max(0, 100 - (sigmaColor * 0.4 + sigmaSpace * 0.2));
      
      updateMetricDisplay('noiseLevelValue', 'noiseLevelBar', noiseLevel);
      updateMetricDisplay('edgeSharpnessValue', 'edgeSharpnessBar', edgeSharpness);
    }

    // Funci칩n para actualizar m칠tricas del filtro gaussiano
    function updateGaussianMetrics(params) {
      const kernelSize = params.kernelSize || 5;
      const sigma = params.sigma || 1.0;
      
      // Calcular nivel de ruido (simulado)
      const noiseLevel = Math.max(0, 100 - (kernelSize * 8 + sigma * 25));
      const smoothingLevel = Math.min(100, kernelSize * 10 + sigma * 30);
      
      updateMetricDisplay('noiseLevelValue', 'noiseLevelBar', noiseLevel);
      updateMetricDisplay('smoothingLevelValue', 'smoothingLevelBar', smoothingLevel);
    }

    // Funci칩n para actualizar m칠tricas del filtro de mediana
    function updateMedianMetrics(params) {
      const kernelSize = params.kernelSize || 5;
      
      // Calcular ruido sal y pimienta (simulado)
      const saltPepperNoise = Math.max(0, 100 - (kernelSize * 12));
      const edgePreservation = Math.max(0, 100 - (kernelSize * 3));
      
      updateMetricDisplay('saltPepperNoiseValue', 'saltPepperNoiseBar', saltPepperNoise);
      updateMetricDisplay('edgePreservationValue', 'edgePreservationBar', edgePreservation);
    }

    // Funci칩n para actualizar m칠tricas de operaciones morfol칩gicas
    function updateMorphologicalMetrics(params) {
      const operation = params.operation || 'opening';
      const kernelSize = params.kernelSize || 5;
      
      let morphologicalQuality = 0;
      let connectivity = 0;
      
      switch(operation) {
        case 'opening':
          morphologicalQuality = Math.max(0, 100 - (kernelSize * 5));
          connectivity = Math.max(0, 100 - (kernelSize * 8));
          break;
        case 'closing':
          morphologicalQuality = Math.max(0, 100 - (kernelSize * 3));
          connectivity = Math.min(100, 50 + (kernelSize * 8));
          break;
        case 'gradient':
          morphologicalQuality = Math.min(100, 30 + (kernelSize * 10));
          connectivity = Math.max(0, 100 - (kernelSize * 6));
          break;
        case 'tophat':
          morphologicalQuality = Math.min(100, 40 + (kernelSize * 7));
          connectivity = Math.max(0, 100 - (kernelSize * 4));
          break;
        case 'blackhat':
          morphologicalQuality = Math.min(100, 35 + (kernelSize * 7));
          connectivity = Math.max(0, 100 - (kernelSize * 4));
          break;
      }
      
      updateMetricDisplay('morphologicalQualityValue', 'morphologicalQualityBar', morphologicalQuality);
      updateMetricDisplay('connectivityValue', 'connectivityBar', connectivity);
    }

    // Funci칩n para actualizar la visualizaci칩n de m칠tricas
    function updateMetricDisplay(valueId, barId, value) {
      const valueElement = document.getElementById(valueId);
      const barElement = document.getElementById(barId);
      
      if (valueElement && barElement) {
        const clampedValue = Math.max(0, Math.min(100, value));
        valueElement.textContent = `${Math.round(clampedValue)}%`;
        barElement.style.width = `${clampedValue}%`;
        
        // Cambiar color seg칰n el valor
        if (clampedValue < 30) {
          barElement.style.backgroundColor = '#ff7a7a'; // Rojo para valores bajos
        } else if (clampedValue < 70) {
          barElement.style.backgroundColor = '#ffa726'; // Naranja para valores medios
        } else {
          barElement.style.backgroundColor = '#8adf85'; // Verde para valores altos
        }
      }
    }

    // Funci칩n para iniciar actualizaci칩n de m칠tricas
    function startMetricsUpdate() {
      // Actualizar m칠tricas iniciales
      updateMetrics();
      
      // Actualizar cada 2 segundos para simular cambios en tiempo real
      setInterval(() => {
        updateMetrics();
      }, 2000);
    }

    // Funci칩n para cargar par치metros actuales del filtro
    function loadCurrentFilterParams(filterType) {
      // Aqu칤 se cargar칤an los par치metros actuales desde el servidor
      // Por ahora usamos valores por defecto
      console.log('Cargando par치metros para filtro:', filterType);
    }

    // Funci칩n para restablecer configuraci칩n
    function resetFilterConfig() {
      if (confirm('쮼st치s seguro de que quieres restablecer la configuraci칩n del filtro?')) {
        loadCurrentFilterParams(currentFilterType);
        showStatus('Configuraci칩n restablecida', 'success');
      }
    }

    // Funci칩n para aplicar configuraci칩n
    function applyFilterConfig() {
      const params = collectFilterParams();
      console.log('Aplicando configuraci칩n:', params);
      showStatus('Configuraci칩n aplicada temporalmente', 'success');
    }

    // Funci칩n para guardar configuraci칩n
    function saveFilterConfig() {
      const params = collectFilterParams();
      console.log('Guardando configuraci칩n:', params);
      showStatus('Configuraci칩n guardada permanentemente', 'success');
    }

    // Funci칩n para recopilar par치metros del filtro
    function collectFilterParams() {
      const params = {
        filterId: currentFilterId,
        filterType: currentFilterType,
        parameters: {}
      };

      switch(currentFilterType) {
        case 'bilateral':
          params.parameters = {
            d: parseInt(document.getElementById('bilateralD')?.value || 15),
            sigmaColor: parseInt(document.getElementById('bilateralSigmaColor')?.value || 75),
            sigmaSpace: parseInt(document.getElementById('bilateralSigmaSpace')?.value || 75)
          };
          break;
        case 'gaussian':
          params.parameters = {
            kernelSize: parseInt(document.getElementById('gaussianKernelSize')?.value || 5),
            sigma: parseFloat(document.getElementById('gaussianSigma')?.value || 1.0)
          };
          break;
        case 'median':
          params.parameters = {
            kernelSize: parseInt(document.getElementById('medianKernelSize')?.value || 5)
          };
          break;
        case 'morphological':
          params.parameters = {
            operation: document.getElementById('morphOperation')?.value || 'opening',
            kernelSize: parseInt(document.getElementById('morphKernelSize')?.value || 5)
          };
          break;
      }

      return params;
    }

    // Funci칩n para mostrar mensajes de estado
    function showStatus(message, type) {
      // Implementar sistema de notificaciones
      console.log(`${type.toUpperCase()}: ${message}`);
    }

    // Variables para autotune
    let isAutoTuning = false;
    let autoTuneProgress = 0;
    let bestParams = null;
    let bestScore = -Infinity;

    // Funci칩n para iniciar autotune
    function startAutoTune() {
      if (isAutoTuning) {
        return;
      }

      if (!confirm('쯀niciar optimizaci칩n autom치tica de par치metros? Este proceso puede tomar varios minutos.')) {
        return;
      }

      isAutoTuning = true;
      autoTuneProgress = 0;
      bestParams = null;
      bestScore = -Infinity;

      const autoTuneBtn = document.getElementById('autoTuneBtn');
      autoTuneBtn.disabled = true;
      autoTuneBtn.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
          <path d="M8 3a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5H6a.5.5 0 0 1 0-1h1.5V3.5A.5.5 0 0 1 8 3zm3.5 1a.5.5 0 0 1 .5.5v3.5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1H11V2.5a.5.5 0 0 1 .5-.5z"/>
          <path d="M8 12a.5.5 0 0 1 .5-.5h1.5v-2H8a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5v2.5a.5.5 0 0 1-.5.5H8.5V12a.5.5 0 0 1-.5.5z"/>
        </svg>
        Optimizando... ${autoTuneProgress}%
      `;

      showStatus('Iniciando optimizaci칩n autom치tica...', 'info');

      // Iniciar optimizaci칩n seg칰n el tipo de filtro
      switch(currentFilterType) {
        case 'bilateral':
          optimizeBilateralFilter();
          break;
        case 'gaussian':
          optimizeGaussianFilter();
          break;
        case 'median':
          optimizeMedianFilter();
          break;
        case 'morphological':
          optimizeMorphologicalFilter();
          break;
        default:
          showStatus('Optimizaci칩n no disponible para este tipo de filtro', 'error');
          stopAutoTune();
      }
    }

    // Funci칩n para detener autotune
    function stopAutoTune() {
      isAutoTuning = false;
      const autoTuneBtn = document.getElementById('autoTuneBtn');
      autoTuneBtn.disabled = false;
      autoTuneBtn.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
          <path d="M8 3a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5H6a.5.5 0 0 1 0-1h1.5V3.5A.5.5 0 0 1 8 3zm3.5 1a.5.5 0 0 1 .5.5v3.5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1H11V2.5a.5.5 0 0 1 .5-.5z"/>
          <path d="M8 12a.5.5 0 0 1 .5-.5h1.5v-2H8a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5v2.5a.5.5 0 0 1-.5.5H8.5V12a.5.5 0 0 1-.5.5z"/>
        </svg>
        Autotune
      `;
    }

    // Funci칩n para actualizar progreso del autotune
    function updateAutoTuneProgress(progress) {
      autoTuneProgress = Math.round(progress);
      const autoTuneBtn = document.getElementById('autoTuneBtn');
      autoTuneBtn.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
          <path d="M8 3a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5H6a.5.5 0 0 1 0-1h1.5V3.5A.5.5 0 0 1 8 3zm3.5 1a.5.5 0 0 1 .5.5v3.5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1H11V2.5a.5.5 0 0 1 .5-.5z"/>
          <path d="M8 12a.5.5 0 0 1 .5-.5h1.5v-2H8a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5v2.5a.5.5 0 0 1-.5.5H8.5V12a.5.5 0 0 1-.5.5z"/>
        </svg>
        Optimizando... ${autoTuneProgress}%
      `;
    }

    // Funci칩n para evaluar la calidad de un conjunto de par치metros
    function evaluateFilterQuality(params) {
      // Simular evaluaci칩n de calidad basada en m칠tricas
      let score = 0;
      
      switch(currentFilterType) {
        case 'bilateral':
          // Evaluar balance entre reducci칩n de ruido y preservaci칩n de bordes
          const noiseReduction = Math.min(100, params.d * 2 + params.sigmaColor * 0.3 + params.sigmaSpace * 0.3);
          const edgePreservation = Math.max(0, 100 - (params.sigmaColor * 0.4 + params.sigmaSpace * 0.2));
          score = (noiseReduction * 0.6) + (edgePreservation * 0.4);
          break;
          
        case 'gaussian':
          // Evaluar balance entre suavizado y preservaci칩n de detalles
          const smoothing = Math.min(100, params.kernelSize * 10 + params.sigma * 30);
          const detailPreservation = Math.max(0, 100 - (params.kernelSize * 5 + params.sigma * 20));
          score = (smoothing * 0.5) + (detailPreservation * 0.5);
          break;
          
        case 'median':
          // Evaluar eliminaci칩n de ruido sal y pimienta vs preservaci칩n de bordes
          const saltPepperRemoval = Math.min(100, params.kernelSize * 12);
          const edgePreservationMedian = Math.max(0, 100 - (params.kernelSize * 3));
          score = (saltPepperRemoval * 0.7) + (edgePreservationMedian * 0.3);
          break;
          
        case 'morphological':
          // Evaluar seg칰n el tipo de operaci칩n
          let morphScore = 0;
          switch(params.operation) {
            case 'opening':
              morphScore = Math.max(0, 100 - (params.kernelSize * 5));
              break;
            case 'closing':
              morphScore = Math.min(100, 50 + (params.kernelSize * 8));
              break;
            case 'gradient':
              morphScore = Math.min(100, 30 + (params.kernelSize * 10));
              break;
            default:
              morphScore = Math.min(100, 40 + (params.kernelSize * 7));
          }
          score = morphScore;
          break;
      }
      
      return score;
    }

    // Funci칩n para optimizar filtro bilateral
    async function optimizeBilateralFilter() {
      const dRange = [5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25];
      const sigmaColorRange = [25, 35, 45, 55, 65, 75, 85, 95, 105, 115, 125, 135, 145, 150];
      const sigmaSpaceRange = [25, 35, 45, 55, 65, 75, 85, 95, 105, 115, 125, 135, 145, 150];
      
      const totalCombinations = dRange.length * sigmaColorRange.length * sigmaSpaceRange.length;
      let currentCombination = 0;
      
      showStatus('Optimizando filtro bilateral...', 'info');
      
      for (const d of dRange) {
        for (const sigmaColor of sigmaColorRange) {
          for (const sigmaSpace of sigmaSpaceRange) {
            if (!isAutoTuning) break;
            
            const params = { d, sigmaColor, sigmaSpace };
            const score = evaluateFilterQuality(params);
            
            if (score > bestScore) {
              bestScore = score;
              bestParams = params;
              showStatus(`Nuevo mejor resultado: ${Math.round(score)}%`, 'success');
            }
            
            currentCombination++;
            const progress = (currentCombination / totalCombinations) * 100;
            updateAutoTuneProgress(progress);
            
            // Peque침a pausa para no saturar la UI
            await new Promise(resolve => setTimeout(resolve, 10));
          }
        }
      }
      
      if (bestParams) {
        applyOptimizedParams(bestParams);
        showStatus(`Optimizaci칩n completada. Mejor score: ${Math.round(bestScore)}%`, 'success');
      }
      
      stopAutoTune();
    }

    // Funci칩n para optimizar filtro gaussiano
    async function optimizeGaussianFilter() {
      const kernelSizeRange = [3, 5, 7, 9, 11, 13, 15];
      const sigmaRange = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3.0];
      
      const totalCombinations = kernelSizeRange.length * sigmaRange.length;
      let currentCombination = 0;
      
      showStatus('Optimizando filtro gaussiano...', 'info');
      
      for (const kernelSize of kernelSizeRange) {
        for (const sigma of sigmaRange) {
          if (!isAutoTuning) break;
          
          const params = { kernelSize, sigma };
          const score = evaluateFilterQuality(params);
          
          if (score > bestScore) {
            bestScore = score;
            bestParams = params;
            showStatus(`Nuevo mejor resultado: ${Math.round(score)}%`, 'success');
          }
          
          currentCombination++;
          const progress = (currentCombination / totalCombinations) * 100;
          updateAutoTuneProgress(progress);
          
          await new Promise(resolve => setTimeout(resolve, 10));
        }
      }
      
      if (bestParams) {
        applyOptimizedParams(bestParams);
        showStatus(`Optimizaci칩n completada. Mejor score: ${Math.round(bestScore)}%`, 'success');
      }
      
      stopAutoTune();
    }

    // Funci칩n para optimizar filtro de mediana
    async function optimizeMedianFilter() {
      const kernelSizeRange = [3, 5, 7, 9, 11, 13, 15];
      
      showStatus('Optimizando filtro de mediana...', 'info');
      
      for (let i = 0; i < kernelSizeRange.length; i++) {
        if (!isAutoTuning) break;
        
        const kernelSize = kernelSizeRange[i];
        const params = { kernelSize };
        const score = evaluateFilterQuality(params);
        
        if (score > bestScore) {
          bestScore = score;
          bestParams = params;
          showStatus(`Nuevo mejor resultado: ${Math.round(score)}%`, 'success');
        }
        
        const progress = ((i + 1) / kernelSizeRange.length) * 100;
        updateAutoTuneProgress(progress);
        
        await new Promise(resolve => setTimeout(resolve, 50));
      }
      
      if (bestParams) {
        applyOptimizedParams(bestParams);
        showStatus(`Optimizaci칩n completada. Mejor score: ${Math.round(bestScore)}%`, 'success');
      }
      
      stopAutoTune();
    }

    // Funci칩n para optimizar operaciones morfol칩gicas
    async function optimizeMorphologicalFilter() {
      const operations = ['opening', 'closing', 'gradient', 'tophat', 'blackhat'];
      const kernelSizeRange = [3, 5, 7, 9, 11, 13, 15];
      
      const totalCombinations = operations.length * kernelSizeRange.length;
      let currentCombination = 0;
      
      showStatus('Optimizando operaciones morfol칩gicas...', 'info');
      
      for (const operation of operations) {
        for (const kernelSize of kernelSizeRange) {
          if (!isAutoTuning) break;
          
          const params = { operation, kernelSize };
          const score = evaluateFilterQuality(params);
          
          if (score > bestScore) {
            bestScore = score;
            bestParams = params;
            showStatus(`Nuevo mejor resultado: ${Math.round(score)}%`, 'success');
          }
          
          currentCombination++;
          const progress = (currentCombination / totalCombinations) * 100;
          updateAutoTuneProgress(progress);
          
          await new Promise(resolve => setTimeout(resolve, 20));
        }
      }
      
      if (bestParams) {
        applyOptimizedParams(bestParams);
        showStatus(`Optimizaci칩n completada. Mejor score: ${Math.round(bestScore)}%`, 'success');
      }
      
      stopAutoTune();
    }

    // Funci칩n para aplicar par치metros optimizados
    function applyOptimizedParams(params) {
      switch(currentFilterType) {
        case 'bilateral':
          document.getElementById('bilateralD').value = params.d;
          document.getElementById('bilateralSigmaColor').value = params.sigmaColor;
          document.getElementById('bilateralSigmaSpace').value = params.sigmaSpace;
          document.getElementById('bilateralDValue').textContent = params.d;
          document.getElementById('bilateralSigmaColorValue').textContent = params.sigmaColor;
          document.getElementById('bilateralSigmaSpaceValue').textContent = params.sigmaSpace;
          break;
          
        case 'gaussian':
          document.getElementById('gaussianKernelSize').value = params.kernelSize;
          document.getElementById('gaussianSigma').value = params.sigma;
          document.getElementById('gaussianKernelSizeValue').textContent = params.kernelSize;
          document.getElementById('gaussianSigmaValue').textContent = params.sigma;
          break;
          
        case 'median':
          document.getElementById('medianKernelSize').value = params.kernelSize;
          document.getElementById('medianKernelSizeValue').textContent = params.kernelSize;
          break;
          
        case 'morphological':
          document.getElementById('morphOperation').value = params.operation;
          document.getElementById('morphKernelSize').value = params.kernelSize;
          document.getElementById('morphKernelSizeValue').textContent = params.kernelSize;
          break;
      }
      
      updateMetrics();
    }

    // Cargar configuraci칩n cuando se carga la p치gina
    document.addEventListener('DOMContentLoaded', loadFilterConfig);
  </script>

  <style>
    /* Estilos espec칤ficos para la p치gina de configuraci칩n de filtros */
    body {
      background: var(--bg);
      color: var(--ink);
    }

    .wrap {
      padding: var(--space-lg);
      max-width: 800px;
      margin: 0 auto;
    }

    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-xl);
      padding-bottom: var(--space-lg);
      border-bottom: 1px solid var(--line);
    }

    .page-header h1 {
      color: var(--ink-bright);
      font-size: var(--font-size-2xl);
      margin: 0;
    }

    .config-section {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius-md);
      padding: var(--space-xl);
      margin-bottom: var(--space-lg);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .config-section h3 {
      color: var(--ink-bright);
      margin-bottom: var(--space-md);
      font-size: var(--font-size-xl);
      border-bottom: 2px solid var(--brand-red);
      padding-bottom: var(--space-sm);
    }

    .filter-description {
      color: var(--muted);
      margin-bottom: var(--space-xl);
      font-size: var(--font-size-base);
      line-height: 1.6;
      background: var(--panel-hover);
      padding: var(--space-md);
      border-radius: var(--radius-sm);
      border-left: 4px solid var(--brand-red);
    }

    /* Panel de m칠tricas */
    .metrics-panel {
      background: var(--panel-hover);
      border: 1px solid var(--line-light);
      border-radius: var(--radius-md);
      padding: var(--space-lg);
      margin-bottom: var(--space-xl);
    }

    .metrics-panel h4 {
      color: var(--ink-bright);
      margin-bottom: var(--space-md);
      font-size: var(--font-size-lg);
      text-align: center;
    }

    .metrics-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--space-lg);
    }

    .metric-card {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius-sm);
      padding: var(--space-md);
    }

    .metric-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-sm);
    }

    .metric-label {
      color: var(--ink);
      font-weight: 600;
      font-size: var(--font-size-sm);
    }

    .metric-value {
      color: var(--brand-red);
      font-weight: 700;
      font-size: var(--font-size-base);
    }

    .metric-bar {
      width: 100%;
      height: 8px;
      background: var(--line);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: var(--space-xs);
    }

    .metric-fill {
      height: 100%;
      background: var(--brand-red);
      border-radius: 4px;
      transition: all 0.3s ease;
    }

    .metric-description {
      color: var(--muted);
      font-size: var(--font-size-xs);
      text-align: center;
      display: block;
    }

    .form-group {
      margin-bottom: var(--space-xl);
    }

    .form-group label {
      display: block;
      margin-bottom: var(--space-sm);
      font-weight: 600;
      color: var(--ink-bright);
      font-size: var(--font-size-lg);
    }

    .range-container {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      margin-bottom: var(--space-sm);
    }

    .range-slider {
      flex: 1;
      height: 6px;
      background: var(--line);
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
      cursor: pointer;
      border: none;
    }

    .range-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: var(--brand-red);
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid var(--panel);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
      transition: all 0.2s ease;
    }

    .range-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: var(--brand-red);
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid var(--panel);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
      transition: all 0.2s ease;
    }

    .range-slider:hover::-webkit-slider-thumb {
      background: #b91c1c;
      transform: scale(1.1);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
    }

    .range-slider:hover::-moz-range-thumb {
      background: #b91c1c;
      transform: scale(1.1);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
    }

    .slider-value {
      color: var(--brand-red);
      font-weight: 600;
      font-size: var(--font-size-base);
      min-width: 40px;
      text-align: center;
      margin: 0;
      padding: 0;
    }

    .param-description {
      color: var(--muted);
      font-size: var(--font-size-sm);
      margin-top: var(--space-xs);
      display: block;
      line-height: 1.5;
      background: var(--panel-hover);
      padding: var(--space-md);
      border-radius: var(--radius-sm);
      border-left: 3px solid var(--line-light);
    }

    .form-control {
      width: 100%;
      padding: var(--space-md);
      background: var(--input-bg);
      border: 1px solid var(--input-border);
      border-radius: var(--radius-sm);
      color: var(--ink);
      font-size: var(--font-size-base);
      transition: all 0.2s ease;
    }

    .form-control:focus {
      outline: none;
      border-color: var(--brand-red);
      box-shadow: 0 0 0 2px rgba(212, 20, 20, 0.25);
      background: var(--input-hover);
    }

    .form-control:hover {
      border-color: var(--line-hover);
      background: var(--input-hover);
    }

    .config-actions {
      display: flex;
      gap: var(--space-md);
      justify-content: center;
      margin-top: var(--space-xl);
      padding-top: var(--space-xl);
      border-top: 1px solid var(--line);
      flex-wrap: wrap;
    }

    /* Estilos para el bot칩n de autotune */
    .btn-warning {
      background: var(--warning);
      color: var(--bg);
      border: 1px solid var(--warning);
    }

    .btn-warning:hover {
      background: #ff9800;
      border-color: #ff9800;
    }

    .btn-warning:disabled {
      background: var(--line);
      color: var(--muted);
      border-color: var(--line-light);
      cursor: not-allowed;
    }

    /* Panel de informaci칩n de optimizaci칩n */
    .optimization-info {
      background: var(--panel-hover);
      border: 1px solid var(--line-light);
      border-radius: var(--radius-md);
      padding: var(--space-md);
      margin-bottom: var(--space-lg);
      text-align: center;
    }

    .optimization-info h4 {
      color: var(--ink-bright);
      margin-bottom: var(--space-sm);
      font-size: var(--font-size-lg);
    }

    .optimization-info p {
      color: var(--muted);
      font-size: var(--font-size-sm);
      line-height: 1.4;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .wrap {
        padding: var(--space-md);
      }
      
      .page-header {
        flex-direction: column;
        gap: var(--space-md);
        text-align: center;
      }
      
      .metrics-grid {
        grid-template-columns: 1fr;
        gap: var(--space-md);
      }
      
      .range-container {
        flex-direction: column;
        align-items: stretch;
        gap: var(--space-sm);
      }
      
      .range-value {
        align-self: center;
      }
      
      .config-actions {
        flex-direction: column;
        align-items: center;
      }
      
      .config-actions .btn {
        width: 100%;
        max-width: 200px;
      }
    }
  </style>
</body>
</html>
